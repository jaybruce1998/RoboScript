//This program evaluates an imaginary language known as RoboScript! RoboScript is a
//language made to control a text-based robot. It knows only 3 commands: Forward, Left
//and Right, where each of those is shortened to simply F, L and R. HOWEVER, this new and
//improved program not only evaluates those commands, but ALSO supports parentheses,
//numbers to repeat commands, and functions that can help repeat commands and define
//nested functions! Whitespace is ignored by the program, so tab and space your code as
//much as you like and watch the little robot go! Here is an example program:
/**
 * p1
    p1
      F R
    q

    F2 P1 // Refers to "inner" (locally defined) P1 so no infinite recursion results
  q

  (
    F2 P1 // Refers to "outer" (global) P1 since the
    // global scope can't "see" local P1
  )4

  /*
    Equivalent to executing the following raw commands:
    F F F F F R F F F F F R F F F F F R F F F F F R
  */
//NOTE: Comments (both single-line and multi-line) are fully supported :)
class RSUProgram {
  //read in the source code given
  constructor(source) {
    this.s=source;
  }
  //tokenize the code that was read in
  getTokens() {
    for(var i=this.s.indexOf("/*"); i>=0; i=this.s.indexOf("/*"))//find all multi-line comments
      //and replace them with spaces so future parsing errors can still be found
      this.s=this.s.substring(0, i)+" "+this.s.substring(this.s.indexOf("*/")+2);
    this.s=this.s.split("\n");//split by newlines to find and DESTROY all single-line comments
    for(var i=0; i<this.s.length; i++)//go through every line of code
    {
      var j=this.s[i].indexOf("//");//look for a comment
      if(j>=0)//if we found one
        this.s[i]=this.s[i].substring(0, j)+" ";//replace it with a space
    }
    this.s=this.s.join("");//get rid of all the line-breaks because they're irrelevant
    if(new RegExp(" [0-9]").test(this.s))//If you want to repeat a command, put it right next to whatever you're repeating!
      throw "Stray number!";
    this.s=this.s.replace(/\s/g, "");//delete all whitespace
    //valid commands are FLR, p for defining a procedure, q for ending said procedure,
    //and digits for repeating commands and procedure calls (such as: (P5)7 which would repeat procedure FIVE 7 times)
    if(new RegExp("[^()pqPFLR0-9]").test(this.s))
      throw "Stray comment!";
    this.s=this.s.split("");//to start with, assume EVERY character is its own token
    for(var i=1; i<this.s.length; i++)//go through every character
      if(!isNaN(this.s[i]))//we found a number!
        this.s[i-1]+=this.s.splice(i--, 1)[0];//so it should be part of the previous token
    for(var i=0; i<this.s.length; i++)//go through every token
      //and if any numbers start with a 0 (like 01, 005, etc.) or any procedures aren't numbered
      if(this.s[i].length>2&&this.s[i][1]=='0'||this.s[i].length==1&&this.s[i][0].toLowerCase()=='p')
        throw "Bad digits!";
    return this.s;
  }
  //given some code, t, we evaluate it within its own scope so inner procs cannot
  //be called from an outer context
  focus(t)
  {
    var M={};//will contain all procedure definitions for this layer of code
    for(var i=0; i<t.length; i++)//go through the given tokens
      if(t[i][0]=='p')//we found a proc!
      {
        var j=i+1, n;
        //all procedures are ended with a q, so find our q!
        for(n=1; n; j++)
          if(t[j]=='q')
            n--;
          else if(t[j][0]=='p')
            n++;
        n=j-i;//splice uses the number of elements, not the index of the last element to splice
        //The procedure map doesn't need p or q (hence the slice) but the tokens don't want them
        //either (hence the splice)
        M[t[i].toUpperCase()]=t.splice(i, n).slice(1, n-1);
        i--;//whenever you splice, it's good to backtrack a little so you don't forget about anyone!
      }
    for(var k in M)//go through all the procs
      for(var i=0; i<M[k].length; i++)//and go through each proc's tokens
        if(M[k][i][0]=='p')//we found an inner procedure!
        {
          var n=this.focus(M[k]), b=true;//so evaluate the inner procedure
          for(var q=0; b&&q<10; q++)//avoids actual infinite recursion
          {
            b=false;
            for(var l in n)//go through all procs generated by the inner proc
            {
              var i=M[k].indexOf(l);
              if(i>=0)//if we use any of those procs
              {
                M[k].splice(i, 1);//delete the procedure call
                for(var j=n[l].length-1; j>=0; j--)
                  M[k].splice(i, 0, n[l][j]);//and replace it with the actual proc code
                b=true;
              }
            }
          }
        }
    return M;//return all the procedures we found!
  }
  /**
   * Convert tokens to raw code (meaning just F's, R's and L's)
   * @param t The tokens to convert
   * @param b An optional parameter to skip initial validation by the converter
   */
  convertToRaw(t, b=true) {
    var m={};//all procs that have been defined
    if(b)//we must check to see that procedures have not been defined in parentheses
      for(var i=0; i<t.length; i++)//so go through every token
        if(t[i]=="(")//look for open parentheses
        {
          var j=i+1;
          for(var n=1; n; j++)
            if(t[j]=="(")
              n++;
            else if(t[j][0]==")")
              n--;
            else if(t[j][0]=='p')//and make sure we don't find this!
              throw "No defining methods in parentheses!";
          i=j-1;
        }
    b=true;
    for(var i=0; i<t.length; i++)//go through the tokens
      if(t[i][0]=='p')//and look for procedure definitions
      {
        var j=i+1, n;
        for(n=1; n; j++)//find the corresponding q for OUR p
          if(t[j]=='q')
            n--;
          else if(t[j][0]=='p')
            n++;
        n=j-i;
        m[t[i].toUpperCase()]=t.splice(i, n).slice(1, n-1);//store the proc definition for later
        i--;
      }
    for(var k in m)//go through all proc definitions
      for(var i=0; i<m[k].length; i++)//go through all procedure tokens
        if(m[k][i][0]=='p')//inner procedure found!
        {
          var n=this.focus(m[k]);//focus in on it so we can get all the inner procedures
          b=true;
          for(var q=0; b&&q<10; q++)//avoids timeout
          {
            b=false;
            for(var l in n)
            {
              var i=m[k].indexOf(l);
              if(i>=0)
              {
                m[k].splice(i, 1);
                for(var j=n[l].length-1; j>=0; j--)
                  m[k].splice(i, 0, n[l][j]);//fill in all procedure calls with corresponding proc definitions
                b=true;
              }
            }
          }
        }
    b=true;
    for(var q=0; b&&q<10; q++)
    {
      b=false;
      for(var i=0; i<t.length; i++)
        for(var k in m)
          if(t[i]==k)
            if(m[k].indexOf(k)>=0)//can't call yourself buddy!
              throw "Infinite recursion!";
            else
            {
              b=true;
              t.splice(i, 1);
              for(var j=m[k].length-1; j>=0; j--)
                t.splice(i, 0, m[k][j]);
            }
    }
    if(t.join("").indexOf("P")>=0)//procedures could not all be accounted for
      throw "Undefined method!";
    for(var i=0; i<t.length; i++)//recursively deal with all parentheses
      if(t[i]=="(")
      {
        var n=1, j, a, l;
        for(j=i+1; n; j++)
          if(t[j]=="(")
            n++;
          else if(t[j][0]==")")
            n--;
        n=t[--j].substring(1);
        j-=i;
        a=this.convertToRaw(t.splice(i, j+1).slice(1, j), false);
        l=a.length-1;
        for(n=n.length?+n:1; n; n--)
          for(j=l; j>=0; j--)
            t.splice(i, 0, a[j]);
        i=-1;
      }
      for(var i=0; i<t.length; i++)//now deal with all the F5's, L17's, etc.
        if(t[i].length>1)
        {
          for(var s=t.splice(i, 1)[0], n=+s.substring(1); n; n--)
            t.splice(i, 0, s[0]);
          i=-1;
        }
    return t;
  }
  //Given just F's, L's and R's, show us where the robot goes!
  executeRaw(c) {
    var r=[["*"]], a=0, b=0, d='r';//robot leaves a * wherever it goes, so start out with
    //one * to show that it existed. Also, they all start facing right!
    for(var i=0; i<c.length; i++)//go through every command
      if(c[i]=="F")//we want to go forward
        if(d=='r')//"forward" is different depending on our direction
        {
          if(++b==r[a].length)//we don't want to go out of bounds!
            for(var k=0; k<r.length; k++)//so extend the bounds for EVERY row of * and spaces
              r[k].push(" ");
          r[a][b]="*";
        }
        else if(d=='l')
        {
          if(!b)//we can't go too far to the left!
          {
            for(var k=0; k<r.length; k++)//so add space to the beginning everywhere
              r[k].unshift(" ")
            b=1;
          }
          r[a][--b]="*";
        }
        else if(d=='u')
        {
          if(!a)//went up too far
          {
            r.unshift([]);//so add another row at the top
            for(var k=0; k<r[1].length; k++)//and fill it in with spaces
              r[0].push(" ");
            a=1;
          }
          r[--a][b]="*";
        }
        else
        {
          if(++a==r.length)//went too far down!
          {
            r.push([]);//put more space down there
            for(var k=0; k<r[0].length; k++)
              r[a].push(" ");
          }
          r[a][b]="*";
        }
      else if(c[i]=="L")//turning left is different from every direction
        if(d=='r')
          d='u';
        else if(d=='u')
          d='l';
        else if(d=='l')
          d='d';
        else
          d='r';
      else//only other command is R, so do R
        if(d=='r')
          d='d';
        else if(d=='d')
          d='l';
        else if(d=='l')
          d='u';
        else
          d='r';
    for(var i=0; i<r.length; i++)//we want a single string for output
      r[i]=r[i].join("");//so make each row a single string
    return r.join("\r\n");//and then join them with Windows-style new-lines
  }
  //given raw user code with spaces and who knows what, show them what it makes the robot do!
  execute() {
    //convert to tokens, convert the tokens to raw commands, and execute them!
    return this.executeRaw(this.convertToRaw(this.getTokens()));
  }
}